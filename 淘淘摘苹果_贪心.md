# 题目描述
又是一年秋季时，陶陶家的苹果树结了n个果子。陶陶又跑去摘苹果，这次他有一个a公分的椅子。当他手够不着时，他会站到椅子上再试试。

这次与NOIp2005普及组第一题不同的是：陶陶之前搬凳子，力气只剩下s了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在s<0之前最多能摘到多少个苹果。

现在已知n个苹果到达地上的高度 x_i，椅子的高度a，陶陶手伸直的最大长度b，陶陶所剩的力气s，陶陶摘一个苹果需要的力气 y_i，求陶陶最多能摘到多少个苹果。

# 输入格式
第 1 行：两个数 苹果数n，力气s。

第 2 行：两个数 椅子的高度 a，陶陶手伸直的最大长度 b。

第 3 行~第 3+n−1 行：每行两个数 苹果高度 x_i，摘这个苹果需要的力气 y_i
# 输出格式
只有一个整数，表示陶陶最多能摘到的苹果数。

# 输入输出样例
## 输入样例 #1
```
8 15
20 130
120 3
150 2
110 7
180 1
50 8
200 0
140 3
120 2
```
## 输出样例 #1
```
4
```
# 说明
对于 100% 的数据，n≤5000, a≤50, b≤200, s≤1000, x_i ≤ 280, y_i ≤ 100。
# 题解
这里使用了贪心算法
```C++
#include<iostream>
#include <algorithm>
using namespace std;
int main()
{
	int n,s,a,b,arr[5001],i,x,y,temp=0,sum;
	cin >> n >> s;
	cin >> a >> b;
	if(n==0)
	{
		cout << 0;
		return 0;
	}
	for(i=0;i<n;i++)
	{
		cin >> x >> y;
		if(x<=a+b)
		{
			arr[temp]=y;
			temp++;
		}
	}
	sort(arr,arr+temp);
	i=0;
	sum=0;
	while(s>=0)
	{
		if(s-arr[i]<0) break;
		else
		{
			s-=arr[i];
			sum++;
			i++;
		}
		if(i>temp) break;
	}
	cout << sum;
	return 0;
}
```